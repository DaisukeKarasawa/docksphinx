# Docksphinx プロダクト要件定義

## プロダクト概要

ローカルPC上の Docker環境を常時監視して、状態変化や負荷の異常をリアルタイムに可視化するツール。

- **プロダクト名**：**Docksphinx（ドックスフィンクス）**
- **CLI**：**`docksphinx`（ドックスフィンクス）**
- **常駐デーモン**：**`docksphinxd`（ドックスフィンクスド）**
- **参考**：`lazygit / lazydocker` のような操作感の TUI を中心に、CLI からも利用できるようにしたい

## 目的・提供価値

- 「いまどのコンテナが動いてるか」「いつからおかしいか」を即座に把握できる
- コンテナの起動・停止・再起動・エラーを見逃さず通知/記録できる
- コンテナ間の依存関係・通信状況を可視化し、原因調査の初動を速くする（開発/検証/運用補助）

## 想定ユーザー

- ローカルで Docker Compose を使う開発者
- Docker環境の状態を把握したいユーザー
- 常駐監視で異常の兆候を拾いたいユーザー

## ユースケース

- 開発中にコンテナが落ちる → "どのコンテナが落ちたか、依存関係を確認"
- コンテナ間通信エラー → "通信状況を可視化"
- リソース不足 → "どのコンテナが重いか確認"
- 多数コンテナが立ち上がる環境（ローカルk8s/compose等）で "いま熱い" を特定

## スコープ

### MVPで実装する機能

#### 監視（収集）

- 一定間隔で、Dockerコンテナ・イメージ・ネットワーク・ボリュームの情報を収集

#### 検知（イベント化）

- 起動・停止・再起動・エラー・閾値超過などをイベントとして生成

#### 可視化

- `docksphinx tui`：TUI でリアルタイム表示、フィルタ、ソート、詳細プレビュー
- `docksphinx tail`：シンプルなストリーミング表示
- `docksphinx snapshot`：現在値を1回取得

#### 運用

- `docksphinxd` の起動/停止/状態確認、設定の永続化

### MVPでは実装しない機能（将来拡張）

- クラウド送信・遠隔ホスト監視
- 自動修復（kill/restartなど実行系）
- GUI（デスクトップ/ブラウザ）
- 高度な分散トレースやコンテナ深掘り
- MCPツール化（段階2以降で追加）

## 機能要件

### 監視対象の指定

- コンテナ名指定
- イメージ名指定
- パターン指定（正規表現/ワイルドカード相当）

### 収集する情報（MVP）

- コンテナID / コンテナ名 / イメージ名
- CPU使用率（近似可）
- メモリ使用量（RSS等）
- 起動からの経過（uptime）
- ネットワーク（送受信バイト数）
- ボリューム（使用量）

### 検知するイベント（MVP）

- `started`：コンテナ起動
- `stopped`：コンテナ停止
- `restarted`：コンテナ再起動
- `died`：コンテナ異常終了
- `cpu_threshold`：CPU閾値超過（**連続N回**で確定）
- `mem_threshold`：メモリ閾値超過（**連続N回**で確定）

### TUI要件

#### レイアウト（複数ペイン）

- **左ペイン**：対象（コンテナ/イメージ/ネットワーク/フィルタ）
- **中央ペイン**：一覧（メトリクス/イベント）
- **右ペイン**：詳細（選択中コンテナの詳細、直近イベント）
- **下ペイン**：ステータス/ヘルプ

#### 操作（MVP）

- パネル切替（Tab/矢印）
- 移動（j/k or ↑/↓）
- フィルタ（`/` 検索）
- ソート切替（CPU/RSS/増加量など）
- 一時停止（ストリーム止めて眺める）
- 終了（q）

### 設定・永続化

- 設定ファイル（監視対象、閾値、収集間隔、出力/表示設定）
- ログ（docksphinxdの稼働ログ、イベント履歴の保持方針はMVPは軽量でOK）

### MCPツール化（オプション、段階2以降）

AIから「Docker環境の状態」を聞けるツール：

- `containers.list`：コンテナ一覧を取得
- `containers.explain_state(container_id)`：コンテナの状態を説明
- `containers.dependencies(container_id)`：依存関係を取得
- `containers.logs(container_id, last_n_lines)`：ログを取得
- `containers.resources(container_id)`：リソース使用量を取得
- `containers.errors(container_id, time_window)`：エラーを検索

**LLM**：AWS EC2/ECS/FargateでOllamaをデプロイ（ユーザビリティを下げないため）

## 非機能要件

- **低オーバーヘッド**：監視自体が重くならない
- **安定性**：長時間動かしても落ちない（常駐前提）
- **読み取り専用**：安全性重視（MVPは実行系操作なし）
- **復元性**：再起動しても設定を読み込み監視再開
- **扱いやすさ**：導入〜起動〜監視開始までが短い（数コマンドで完了）

## 技術スタック

### コア技術（MVP）

- **goroutine/channel**：複数コンテナの並列監視、イベント処理、購読者管理
- **gRPC**：デーモンとCLIの通信、ストリーミングでリアルタイム配信
- **Docker API**：Docker Engine APIでコンテナ・イメージ・ネットワーク・ボリュームの状態を取得

### 拡張技術（段階2以降）

- **MCP(go-sdk)**：MCPツールを作成、内部的にgRPCを呼ぶ
- **AWS/CDK/サーバーレス**：
  - AWS EC2/ECS/FargateでOllamaをデプロイ（LLM）
  - S3でイベント履歴を保存（長期保存）
  - DynamoDBでイベント履歴を管理（検索・集計）
  - Lambdaでイベント処理（通知・アラート）
  - CDKでIaC（デプロイ・設定管理）

## リスク・制約

- OSごとに取得できるメトリクスが異なる（CPU%定義など）
  - **対策**：Macbook に限定する
- "同名コンテナの追跡"は誤判定しうる（MVPは割り切り、将来改善）
- 収集間隔を短くしすぎると監視側が負荷になる（下限を設ける）

## 成功条件（MVP）

- `docksphinx tui` で「いま熱いコンテナ」「落ちた/再起動した」が直感的に分かる
- フィルタとソートで原因候補へ到達するまでが速い
- 閾値イベントがチャタらず（連続判定）、調査に使える粒度で残る
- 常駐してもPC体験を損ねない負荷で動く
